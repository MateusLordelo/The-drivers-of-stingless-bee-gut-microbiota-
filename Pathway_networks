###### Now running the networks for metacyc pathways

library(phyloseq)
library(SpiecEasi)
library(Matrix)
library(igraph)


ps_filtered <- readRDS("ps_Pathway_filtered.rds")
# Extract filtered counts
otu_table_filtered <- as(otu_table(ps_filtered), "matrix")
if (taxa_are_rows(ps_filtered)) {
  otu_table_filtered <- t(otu_table_filtered)
}

# Check dimensions
dim(otu_table_filtered)

###seems right, we had 53 taxa and 30 samples

# Run SpiecEasi (MB method is common for microbiome data)
se.mb <- spiec.easi(
  otu_table_filtered, 
  method = "mb",             # Meinshausen-BÃ¼hlmann
  lambda.min.ratio = 1e-2,   # default
  nlambda = 20,              # number of regularization parameters
  sel.criterion = "stars",   # stability approach
  pulsar.params = list(rep.num = 20)  # bootstrap reps
)

# Extract adjacency matrix
spiec_adj <- as.matrix(getRefit(se.mb))

# Create igraph object
spiec_net <- adj2igraph(spiec_adj, vertex.attr = list(name = colnames(otu_table_filtered)))

# Summary
print(spiec_net)


######sparcc

# Run SparCC correlations
sparcc_res <- SpiecEasi::sparcc(otu_table_filtered)

# Get correlation matrix
sparcc_cor <- sparcc_res$Cor

# Apply a threshold to keep only strong correlations
# e.g., |r| > 0.3
threshold <- 0.3
sparcc_adj <- abs(sparcc_cor) > threshold

# Build igraph
sparcc_net <- graph.adjacency(sparcc_adj, mode = "undirected", diag = FALSE)
V(sparcc_net)$name <- colnames(otu_table_filtered)

# Summary
print(sparcc_net)



######compare them

# Get edges as data frames
edges_spiec <- as.data.frame(get.edgelist(spiec_net))
edges_sparcc <- as.data.frame(get.edgelist(sparcc_net))

# Add method labels
edges_spiec$method <- "SpiecEasi"
edges_sparcc$method <- "SparCC"

# Combine
edges_combined <- rbind(edges_spiec, edges_sparcc)

# See how many edges overlap
common_edges <- merge(edges_spiec, edges_sparcc, by = c("V1","V2"))
cat("Edges in both methods:", nrow(common_edges), "\n")



##### first look:
par(mfrow=c(1,2))
plot(spiec_net, main="SpiecEasi Network", vertex.size=5, vertex.label=NA)
plot(sparcc_net, main="SparCC Network", vertex.size=5, vertex.label=NA)


### add stuff:

# ADAPTED METADATA EXTRACTION
pathway_tax_df <- as.data.frame(tax_table(ps_filtered))

# Create a clean metadata table for matching
taxa_meta <- data.frame(
  Pathway_ID = taxa_names(ps_filtered), # Pathway IDs are the names/ASVs
  # RENAME these columns to reflect MetaCyc hierarchy:
  Second_Level = pathway_tax_df[, "Second_Level"],
  Top_Level    = pathway_tax_df[, "Top_Level"],
  stringsAsFactors = FALSE
)

# Add attributes to SpiecEasi network
match_index_spiec <- match(V(spiec_net)$name, taxa_meta$Pathway_ID)
V(spiec_net)$Second_Level <- taxa_meta$Second_Level[match_index_spiec]
V(spiec_net)$Top_Level    <- taxa_meta$Top_Level[match_index_spiec]

# Add attributes to SparCC network
match_index_sparcc <- match(V(sparcc_net)$name, taxa_meta$Pathway_ID)
V(sparcc_net)$Second_Level <- taxa_meta$Second_Level[match_index_sparcc]
V(sparcc_net)$Top_Level    <- taxa_meta$Top_Level[match_index_sparcc]


library(RColorBrewer)
library(igraph)
library(dplyr)

# Extract taxonomy metadata
taxa_meta <- data.frame(
  Pathway_ID = taxa_names(ps_filtered),
  Second_Level = tax_table(ps_filtered)[, "Second_Level"],
  Top_Level    = tax_table(ps_filtered)[, "Top_Level"],
  stringsAsFactors = FALSE
)

# Unique pathway classes
second_levels <- unique(taxa_meta$Second_Level)
num_classes <- length(second_levels)
colors <- c(
  "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd",
  "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf",
  "#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#78e",
  "#e31a1c", "#fdbf6f", "#f00", "#cab2d6", "#6a3d9a",
  "#ffff99", "#b15928", "#ffd92f", "#b3b3b3", "#ccebc5",
  "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#32e", "yellow", "#e6194b", "#3cb44b", "#ffe119", "#0082c8", "#f58231",
  "#911eb4", "#46f0f0", "#f032e6", "#d2f53c", "#fabebe",
  "#008080", "#e6beff", "#aa6e28", "#800000", "#aaffc3",
  "#808000", "#ffd8b1", "#000080", "#808080", "#032bec",
  "#000000", "#7cfc00", "#40e0d0", "#6495ed", "#ff4500",
  "#32cd32", "#8a2be2", "#ff1493", "#00ff7f", "#dc143c",
  "#ffd700", "#ff69b4", "#00ced1", "#9932cc", "#ff6347")

names(colors) <- second_levels

# Add metadata to each network
add_meta <- function(net, meta) {
  match_index <- match(V(net)$name, meta$Pathway_ID)
  V(net)$Second_Level <- meta$Second_Level[match_index]
  V(net)$Top_Level    <- meta$Top_Level[match_index]
  return(net)
}

spiec_net <- add_meta(spiec_net, taxa_meta)
sparcc_net <- add_meta(sparcc_net, taxa_meta)


library(ggraph)
library(tidygraph)
library(ggplot2)
library(patchwork)

# Convert igraph to tidygraph
spiec_tbl  <- as_tbl_graph(spiec_net)
sparcc_tbl <- as_tbl_graph(sparcc_net)

# Plot function (no labels)
plot_network <- function(tbl, title, color_map) {
  ggraph(tbl, layout = "fr") +
    geom_edge_link(color = "gray80", alpha = 0.7) +
    geom_node_point(aes(color = Second_Level), size = 4) +
    scale_color_manual(values = color_map, na.value = "black") +
    theme_void() +
    ggtitle(title) +
    theme(legend.position = "none",
          plot.title = element_text(hjust = 0.5))
}

p1 <- plot_network(spiec_tbl, "SpiecEasi Network", colors)
p2 <- plot_network(sparcc_tbl, "SparCC Network", colors)

# Shared legend on the right
legend <- cowplot::get_legend(
  ggraph(spiec_tbl, layout = "fr") +
    geom_node_point(aes(color = Second_Level), size = 4) +
    scale_color_manual(values = colors, name = "Pathway (Second Level)") +
    theme(legend.position = "right")
)

# Combine plots
combined_plot <- cowplot::plot_grid(p1, p2, legend, ncol = 3, rel_widths = c(1,1,0.3))
combined_plot

# Optionally save:
ggsave("Networks_SideBySide.png", combined_plot, width = 12, height = 6, dpi = 300)




get_network_stats <- function(net, name, cor_matrix = NULL) {
  # Basic stats
  n_nodes <- vcount(net)
  n_edges <- ecount(net)
  avg_deg <- mean(degree(net))
  dens <- edge_density(net)
  avg_path <- ifelse(is_connected(net), mean_distance(net), NA)
  diam <- ifelse(is_connected(net), diameter(net), NA)
  trans <- transitivity(net)
  
  # Modularity (using detected communities)
  comm <- cluster_fast_greedy(net)
  modularity_val <- modularity(comm)
  
  # Positive/negative edges (if correlation matrix available)
  pos <- neg <- NA
  if (!is.null(cor_matrix)) {
    # explicitly call igraph::as_data_frame to avoid tibble conflict
    edge_df <- igraph::as_data_frame(net, what = "edges")
    # match edge correlation values safely
    vals <- mapply(function(a, b) {
      if (a %in% rownames(cor_matrix) && b %in% colnames(cor_matrix)) {
        return(cor_matrix[a, b])
      } else {
        return(NA)
      }
    }, edge_df$from, edge_df$to)
    vals <- vals[!is.na(vals)]
    pos <- sum(vals > 0)
    neg <- sum(vals < 0)
  }
  
  data.frame(
    Network = name,
    Nodes = n_nodes,
    Edges = n_edges,
    Positive_Edges = pos,
    Negative_Edges = neg,
    Avg_Degree = avg_deg,
    Density = dens,
    Avg_Path_Length = avg_path,
    Diameter = diam,
    Transitivity = trans,
    Modularity = modularity_val
  )
}


# Compute stats for both
stats_spiec  <- get_network_stats(spiec_net, "SpiecEasi")
stats_sparcc <- get_network_stats(sparcc_net, "SparCC", cor_matrix = sparcc_cor)

network_stats <- dplyr::bind_rows(stats_spiec, stats_sparcc)
print(network_stats)
write.csv(network_stats, "Network_Statistics.csv", row.names = FALSE)





